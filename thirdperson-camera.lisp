(in-package :thirdperson-controller)

(defparameter *mouse-speed* 5.4)

(defparameter *movement-speed* 0.15)
(defparameter *gravity* 9.8)
(defparameter *jumping* nil)
(defparameter *jump-force* 16)
(defparameter *ground-check-ray* (vec3 :y -1.2))
(defparameter *ray-end* (vec3))
(defparameter *ground-normal* (vec3))

((ffi:ref (find-by-name "RAYCAST-ENDPOINT") set-position) (vec3 :x 0 :y 3.643 :z 10))

(defun set-up-camera (camera)
  (let ((eulers (vec3))
        (app (ffi:ref js:pc app))
        (cam-ray-end (find-by-name "RAYCAST-ENDPOINT")))
    (labels ((on-mouse-move (e &rest _)
               (if (eql ((ffi:ref js:pc -mouse is-pointer-locked)) js:true)
                   (progn 
                     (js-setf (eulers x) (- (ffi:ref eulers x)
                                                    (mod (* (* *mouse-speed* (ffi:ref e dx)) 0.01666666) 360))
                              (eulers y) (+ (ffi:ref eulers y) (mod (* (* *mouse-speed* (ffi:ref e dy)) 0.01666666) 360)))
                     (if (< (ffi:ref eulers x) 0)
                         (ffi:set (ffi:ref eulers x) (+ (ffi:ref eulers x) 360)))
                     (if (> (ffi:ref eulers x) 360)
                         (ffi:set (ffi:ref eulers x) (- (ffi:ref eulers x) 360)))
                     (if (> (ffi:ref eulers y) 90)
                         (ffi:set (ffi:ref eulers y) 90))
                     (if (< (ffi:ref eulers y) -90)
                         (ffi:set (ffi:ref eulers y) -90)))))
             (on-mouse-down (e &rest _)
               ((ffi:ref app mouse enable-pointer-lock)))
             (jump (&rest _)
               (let ((entity (ffi:ref camera parent parent)))
                 (if (and (not (eql (ffi:ref entity on-ground) js:null))
                          (not *jumping*))
                     (progn
                       ((ffi:ref entity rigidbody apply-impulse) 0 *jump-force* 0)
                       (setf *jumping* t)
                       (js-setf (entity on-ground) js:null)
                       (js:set-timeout ((ffi:ref (lambda () (setf *jumping* nil))
                                                 "bind") entity) 360)))))
             (get-world-point (&rest _)
               (let* ((from ((ffi:ref camera parent get-position)))
                      (to ((ffi:ref cam-ray-end get-position)))
                      (hit ((ffi:ref app systems rigidbody raycast-first) from to)))
                 (if (not (eql hit js:null))
                     (ffi:ref hit point)
                     to)))
             (p-update (dt &rest _)
               (let* ((origin-entity (ffi:ref camera parent))
                     (target-y (+ (ffi:ref eulers x) 180))
                     (target-x (ffi:ref eulers y))
                     (target-ang (vec3 :x (- target-x) :y target-y)))
                 ((ffi:ref origin-entity set-euler-angles) target-ang)
                 ((ffi:ref camera set-position) (funcall #'get-world-point))
                 ((ffi:ref camera look-at) origin-entity)))
             (update-jump (dt &rest _)
               (let* ((entity (ffi:ref camera parent parent))
                      (pos ((ffi:ref entity get-position))))
                 ((ffi:ref *ray-end* "add2") pos *ground-check-ray*)
                 (let ((result ((ffi:ref js:pc "app" "systems" "rigidbody" "raycastFirst") pos *ray-end*)))
                   (js-setf (entity on-ground) result)
                   (if nil
                       ((ffi:ref entity rigidbody apply-force) (vec3 :y (- *gravity*))))
                   (if (not (eql result js:null))
                       ((ffi:ref *ground-normal* copy) (ffi:ref result normal))))))
             (update-movement (dt &rest _)
               (let* ((entity (ffi:ref camera parent parent))
                     (world-direction (vec3))
                     (temp-direction (vec3))
                     (forward (ffi:ref camera forward))
                     (right (ffi:ref camera right))
                     (x 0)
                     (z 0))
                 (if (is-pressed-p "KEY_A")
                     (decf x))
                 (if (is-pressed-p "KEY_D")
                     (incf x))
                 (if (is-pressed-p "KEY_W")
                     (incf z))
                 (if (is-pressed-p "KEY_S")
                     (decf z))
                 (if (is-pressed-p "KEY_SPACE")
                     (jump))
                 (if (or 
                      (not (zerop x))
                      (not (zerop z)))
                     (progn
                       ((ffi:ref world-direction add) 
                        ((ffi:ref ((ffi:ref temp-direction copy) forward) mul-scalar) z))
                       ((ffi:ref world-direction add) 
                        ((ffi:ref ((ffi:ref temp-direction copy) right) mul-scalar) x))
                       ((ffi:ref world-direction normalize))
                       (let* ((pos (vec3 :x (* (ffi:ref world-direction x) dt)
                                         :z (* (ffi:ref world-direction z) dt)))
                             (target-y (+ (ffi:ref eulers x) 180))
                             (rot (vec3 :y target-y)))
                         ((ffi:ref ((ffi:ref pos normalize)) scale) *movement-speed*)
                         ((ffi:ref pos add) ((ffi:ref entity get-position)))
                         ((ffi:ref entity rigidbody teleport) pos (ffi:ref entity rotation))))))))
      (on mousemove (ffi:ref app mouse) #'on-mouse-move camera)
      (on mousedown (ffi:ref app mouse) #'on-mouse-down camera)
      (add-to-update :cam #'p-update)
      (add-to-update :movement #'update-movement)
      (add-to-update :jump #'update-jump))))


